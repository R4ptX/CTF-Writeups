# Chall

Here is the source code that was given with the challenge:


```python
from Crypto.Util import number

def nextprime(n):
	p = n
	while True:
		if number.isPrime(p := p+1): return p

p = number.getPrime(512)
q = nextprime(p)
r = nextprime(q)
n = p*q*r
e = 0x10001
flag = int.from_bytes(open('flag.txt','r').read().encode())
c = pow(flag,e,n)
print(n)
print(c)
```

# Solution

The vulnerability is the following: since the primes generated are 3 consecutive primes, they are all close to the cubic root of the RSA modulus n.
Remark: even if an RSA modulus is not generated by consecutive primes but with primes which are close enough relatively to n, it is still insecure since n can be factored with well documented techniques.

Thus, we can factor n by looking to the closest primes to the cubic root of n.

Here is a sample solve script:


```python
from sympy.functions.elementary.miscellaneous import cbrt
from Crypto.Util import number

n = 382580123463439333374967523042465444750859355411511244002722477032105615517233611853076443917769915517149940578043632793948817928808073889749635781692193165564767291423181453275836035725564978497610997324814846346941354849330838086703183416091675031964370452318661563681801079649619408369324242132752776511307965899426923576659494582602720167488298920822412349598413307002580507878918110067681918145351532495520947417885705276912874911313845356317249809458424531
c = 316696667144774910970239315329841661592829035775893005298239390044851378604809212693703157273955815407268756581448131969723818836545789492884652680941594254356039910525338979909161101504241952652459934177507044870418324267497048596017193179199827330094190144091563314834895067780965618959606144021888577049311571838342422901286401185802787290006979592945104702695612274533755366046683817812436556870586561347970749814404707213386183599241707817564309353517647338

def nextprime(n):
	p = n
	while True:
		if number.isPrime(p := p+1): return p
		
cube_root = int(cbrt(n))
print(nextprime(cube_root))
p = nextprime(cube_root)
q = nextprime(p)
r = n//(p*q)

phi = (p-1)*(q-1)*(r-1)
e = 0x10001
 
d = pow(e, -1, phi)
print(number.long_to_bytes(pow(c,d,n)))
```

It allows to retrieve the flag ```ENO{1_l0ve_7h3_pr1me_numb3r_the0r3m}```
